# version 2020.8.23
# version 2020.9.21, add classification information
# version 2021.1.7, add (step 15) icamp.cate to summarize for different categories of taxa, e.g. core versus rare taxa.

library(phyloseq)
library(tidyverse)
library(iCAMP)
library(ape)
library(metagMisc)
library(readxl)
library(lemon)

t0=Sys.time() # to calculate time cost

setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()

ps <- readRDS("../../data/Phyloseq_data/ps_seq_PVC.rds")
# to be discarded an otu has to be present in less than 1% of samples and have a total count of less than the specify threshold
ps <- phyloseq_filter_prevalence(ps, prev.trh = 0.01, abund.trh = 20, threshold_condition = "OR", abund.type = "total")

colnames(sample_data(ps))

# the OTU table file (Tab delimited txt file)
comm <- t(data.frame(otu_table(ps)))

# the phylogenetic tree file
tree=phy_tree(ps)

# the classification (taxonomy) information
clas=data.frame(tax_table(ps))

# the treatment informaiton table
treat= data.frame(sample_data(ps)) %>% 
  select(Status)

rownames(treat) <- rownames(comm)

unique(treat$Status)

# the environmental varialbes
env=data.frame(sample_data(ps)) %>% 
  select(13:25) %>% 
  select(Ca, everything())

rownames(env) <- rownames(comm)

# 2 # key parameter setting
prefix="CIAT"  # prefix of the output file names. usually use a project ID.
rand.time=1000  # randomization time, 1000 is usually enough. For example test, you may set as 100 or less to save time.
nworker=7 # nworker is thread number for parallel computing, which depends on the CPU core number of your computer.
memory.G=50 # to set the memory size as you need (but should be less than the available space in your hard disk), so that calculation of large tree will not be limited by physical memory. unit is Gb.

# 4 # match sample IDs in OTU table and treatment information table
sampid.check=match.name(rn.list=list(comm=comm,treat=treat,env=env))
# the output should be "All match very well".
# for your data files, if you have not matched their IDs, the unmatched samples will be removed.

# 5 # match OTU IDs in OTU table and tree file
spid.check=match.name(cn.list=list(comm=comm),rn.list=list(clas=clas),tree.list=list(tree=tree))
# for the example data, the output should be "All match very well".
# for your data files, if you have not matched the IDs before, the unmatched OTUs will be removed.

# 6 # calculate pairwise phylogenetic distance matrix.
# since microbial community data usually has a large number of species (OTUs or ASVs), we use "big.matrix" in R package "bigmemory" to handle the large phylogenetic distance matrix. 

pd.big=iCAMP::pdist.big(tree = tree, wd="../outputs/", nworker = nworker, memory.G = memory.G)
  # output files:
  # path.rda: a R object to list all the nodes and  edge lengthes from root to every tip. saved in R data format. an intermediate output when claculating phylogenetic distance matrix.
  # pd.bin: BIN file (backingfile) generated by function big.matrix in R package bigmemory. This is the big matrix storing pairwise phylogenetic distance values. By using this bigmemory format file, we will not need memory but hard disk when calling big matrix for calculation.
  # pd.desc: the DESC file (descriptorfile) to hold the backingfile (pd.bin) description.
  # pd.taxon.name.csv: comma delimited csv file storing the IDs of tree tips (OTUs), serving as the row/column names of the big phylogenetic distance matrix.


####################
# you may skip step 7-8, if the "alternative way" based on stochasticity is applicable, as mentioned in the method part of iCAMP paper (Ning et al 2020 Nature Communications).
# 7 # assess niche preference difference between species
# env is required for this step.
# since microbial community data usually has a large number of species (OTUs or ASVs), we use "big.matrix" in R package "bigmemory" to handle the large niche difference matrix. 

# use big memo TRUE to save output rather than working in memory  
niche.dif=iCAMP::dniche(env = env,comm = comm,method = "niche.value",
                        nworker = nworker,out.dist=FALSE,bigmemo=FALSE)
niche.dif$nd$K[1:3,1:5]

# 8 # within-bin phylogenetic signal assessment.
# For real data, you may try several different settings of binning, and choose the one leading to the best within-bin phylogenetic signal.
# env is required for this step.
# 8.1 # try phylogenetic binning using current setttings.
ds = 0.2 # setting can be changed to explore the best choice
bin.size.limit = 10# setting can be changed to explore the best choice. 

is.rooted(tree)
# if tree is not rooted
tree <- root(tree, 1, resolve.root = TRUE)

phylobin=taxa.binphy.big(tree = tree, pd.desc = "../outputs/pd.desc",pd.spname = pd.big$tip.label,
                         pd.wd = "../outputs/", ds = ds, bin.size.limit = bin.size.limit,
                         nworker = nworker)

?taxa.binphy.big
# 8.2 # test within-bin phylogenetic signal.
sp.bin=phylobin$sp.bin[,3,drop=FALSE]
sp.ra=colMeans(comm/rowSums(comm))
abcut=3 # you may remove some species, if they are too rare to perform reliable correlation test. We already done this at the beginnin though
commc=comm[,colSums(comm)>=abcut,drop=FALSE]
dim(commc)
spname.use=colnames(commc)

?ps.bin

binps=iCAMP::ps.bin(sp.bin = sp.bin, sp.ra = sp.ra,spname.use = spname.use,
                    pd.desc = pd.big$pd.file, pd.spname = pd.big$tip.label, pd.wd = pd.big$pd.wd,
                    nd.list = niche.dif$nd,nd.spname = niche.dif$names,ndbig.wd = niche.dif$nd.wd,
                    cor.method = "pearson",r.cut = 0.1, p.cut = 0.05, min.spn = 5)

binps$Index # best options seems to be ds=0.2 and bin limit =10. 

# since this example small data is randomly generated, the correlation should be very weak.
# usually, you are looking for a binning setting lead to higher RAsig.abj (relative abundance of bins with significant phylogenetic signal) and relative high meanR (mean correlation coefficient across bins).
# see help document of the function "ps.bin" for the meaning of output.

####################
# 9 # iCAMP analysis
# 9.1 # without omitting small bins.
# commonly use # set sig.index as Confidence instead of SES.RC (betaNRI/NTI + RCbray)
bin.size.limit = 10 # For real data, usually use a proper number according to phylogenetic signal test or try some settings then choose the reasonable stochasticity level. our experience is 12, or 24, or 48. but for this example dataset which is too small, have to use 5.
sig.index="Confidence" # see other options in help document of icamp.big.
icres=iCAMP::icamp.big(comm=comm, pd.desc = pd.big$pd.file, pd.spname=pd.big$tip.label,
                       pd.wd = pd.big$pd.wd, rand = rand.time, tree=tree,
                       prefix = prefix, ds = 0.2, pd.cut = NA, sp.check = TRUE,
                       phylo.rand.scale = "within.bin", taxa.rand.scale = "across.all",
                       phylo.metric = "bMPD", sig.index=sig.index, bin.size.limit = bin.size.limit, 
                       nworker = nworker, memory.G = memory.G, rtree.save = FALSE, detail.save = TRUE, 
                       qp.save = FALSE, detail.null = FALSE, ignore.zero = TRUE, output.wd = "../outputs/", 
                       correct.special = TRUE, unit.sum = rowSums(comm), special.method = "depend",
                       ses.cut = 1.96, rc.cut = 0.95, conf.cut=0.975, omit.option = "no",meta.ab = NULL)

?icamp.big
saveRDS(icres, "../outputs/ICAMP.detail.rda")
icres <- readRDS("../outputs/ICAMP.detail.rda")
  
# pairwise comparison
icres$CbMPDiCBraya

# there are quite a few parameters in this function, please check the help document of "icamp.big".
# output files:
# Test.iCAMP.detail.rda: the object "icres" saved in R data format. it is a list object. The first element bNRIiRCa is the result of relative importance of each assembly process in each pairwise comparison (each turnover). 
#The second element "detail" including binning information (named taxabin), phylogenetic and taxonomic metrics results in each bin (named like bNRIi, RCa, etc.), relative abundance of each bin (bin.weight), 
#relative importance of each process in each turnover between communities (processes), input settings (setting), and input community data matrix (comm). See help document of the function icamp.big for more details.

############################

# 10 # iCAMP bin level statistics
icbin=icamp.bins(icamp.detail = icres$detail,treat = treat,
                 clas=clas,silent=FALSE, boot = TRUE,
                 rand.time = rand.time,between.group = TRUE)

?icamp.bins

global.imp <- icbin$Pt

proc.group <- icbin$BPtk
class(proc.group)
bin.group <- icbin$Ptk
class(bin.group)

taxas <- icbin$Class.Bin
class(taxas)

save(icbin,file = paste0(prefix,".iCAMP.Summary.rda")) # just to archive the result. rda file is automatically compressed, and easy to load into R.
write.csv(icbin$Pt,file = paste0(prefix,".ProcessImportance_EachGroup.csv"),row.names = FALSE)
write.csv(icbin$Ptk,file = paste0(prefix,".ProcessImportance_EachBin_EachGroup.csv"),row.names = FALSE)
write.csv(icbin$Ptuv,file = paste0(prefix,".ProcessImportance_EachTurnover.csv"),row.names = FALSE)
write.csv(icbin$BPtk,file = paste0(prefix,".BinContributeToProcess_EachGroup.csv"),row.names = FALSE)

write.csv(data.frame(ID=rownames(icbin$Class.Bin),icbin$Class.Bin,stringsAsFactors = FALSE),
          file = paste0(prefix,".Taxon_Bin.csv"),row.names = FALSE)
write.csv(icbin$Bin.TopClass,file = paste0(prefix,".Bin_TopTaxon.csv"),row.names = FALSE)

# output files:
# Test.iCAMP.Summary.rda: the object "icbin" saved in R data format. see help document of the function icamp.bins for description of each element in the object.
# Test.ProcessImportance_EachGroup.csv: Relative importance of each process in governing the turnovers in a group of samples.
# Test.ProcessImportance_EachBin_EachGroup.csv: Relative importance of each process in governing the turnovers of each bin among a group of samples.
# Test.ProcessImportance_EachTurnover.csv: Relative importance of each process in governing the turnovers between each pair of communities (samples).
# Test.BinContributeToProcess_EachGroup.csv: Bin contribution to each process, measuring the contribution of each bin to the relative importance of each process in the assembly of a group of communities.
# Test.Taxon_Bin.csv: a matrix showing the bin ID and classification information for each taxon.
# Test.Bin_TopTaxon.csv: a matrix showing the bin relative abundance; the top taxon ID, percentage in bin, and classification; the most abundant name at each phylogeny level in the bin.

# 11 # Bootstrapping test
# please specify which column in the treatment information table.
i=1
treat.use=treat[,i,drop=FALSE]
icamp.result=icres$CbMPDiCBraya
icboot=iCAMP::icamp.boot(icamp.result = icamp.result,treat = treat.use,rand.time = rand.time,
                         compare = TRUE,silent = FALSE,between.group = TRUE,ST.estimation = TRUE)

?icamp.boot

icboot$summary
boot.comp <- icboot$compare

save(icboot,file=paste0(prefix,".iCAMP.Boot.",colnames(treat)[i],".rda"))
write.csv(icboot$summary,file = paste0(prefix,".iCAMP.BootSummary.",colnames(treat)[i],".csv"),row.names = FALSE)
write.csv(icboot$compare,file = paste0(prefix,".iCAMP.Compare.",colnames(treat)[i],".csv"),row.names = FALSE)



# first plot look at the overall importance of ecological processes
load("../outputs/CIAT.iCAMP.Boot.Status.rda")

icboot$summary[,1:5] %>%
  mutate(Mean=as.numeric(Mean)) %>% 
  filter(Process!="Stochasticity") %>% 
  filter(Group%in%c("Domesticated", "Wild")) %>% 
  ggplot(aes(Group, y=Mean, fill=Process)) +
  geom_bar(stat = "identity", color="black")+
  ylab("RI (%)")+
  xlab("")+
  theme_Publication(base_family = 12)

# differences in ecological processes between groups

icboot$compare %>%
  filter(Group1%in%c("Wild"), Group2%in%c("Domesticated")) %>% 
  slice(-2)


# most important bins, in terms or relative abundance

load("../outputs/CIAT.iCAMP.Summary.rda")

icbin$Bin.TopClass %>% 
  arrange(desc(BinRA)) %>% 
  filter(BinRA>0.01) %>% 
  ggplot() +
  geom_bar(aes(fill=Bin, x="Bin", y=BinRA), color="black",position="stack",stat="identity")+
  theme_Publication(base_family = 12)

sum(sort(icbin$Bin.TopClass$BinRA, decreasing = TRUE)[1:5]) # first 5 bins account for 45% of abundances. First bin 18%. 

top5 <- icbin$Bin.TopClass %>% 
  arrange(desc(BinRA)) %>% 
  filter(BinRA>0.01) %>% 
  select(Bin) %>% 
  slice(1:5)

icbin$Bin.TopClass %>% 
  filter(Bin%in%top5$Bin)%>% 
  ggplot() +
  geom_bar(aes(fill=Family.maxNamed, x=Bin, y=Family.maxNamed.Percent), color="black",position="stack",stat="identity")+
  theme_Publication(base_family = 12)+
  ylab("Relative abundance within Bin")+
  coord_flip()

# processes driving the assembly of the most important bins

top5 <- str_replace(top5$Bin, "B", "b")

icbin$Ptk %>% 
  select(1:4,top5) %>% 
  filter(Index%in%c("HeS","HoS","DL","HD","DR")) %>% 
  filter(Group%in%c("Wild","Domesticated")) %>% 
  gather(key="bins", value, 5:9) %>% 
  mutate(value=as.numeric(value)) %>% 
  ggplot(aes(bins, value, fill=Index))+
  geom_bar(stat="identity", color="black")+
  facet_rep_wrap(~Group, nrow=2, repeat.tick.labels = "all")+
  theme_Publication(base_size = 12)+
  theme(axis.text.x=element_text(angle=45,hjust=1))+
  coord_flip()

# Average mean by Order and Phylum

Fam_bin <-  icbin$Bin.TopClass %>% 
  select(Bin, TopTaxon.Order, TopTaxon.Phylum, TopTaxon.Family) %>% 
  mutate(Bin=str_replace(Bin, "B", "b"))

RI_fam <- icbin$Ptk %>% 
  pivot_longer(cols = 5:ncol(icbin$Ptk), names_to = "Bin", values_to = "RI") %>% 
  left_join(., Fam_bin )

RI_fam %>% 
  filter(Index%in%c("HeS","HoS","DL","HD","DR")) %>% 
  filter(Group%in%c("Wild","Domesticated")) %>% 
  mutate(value=as.numeric(RI)) %>%
  group_by(Index, Group,  TopTaxon.Order) %>% 
  summarise(value=mean(value)) %>% 
  pivot_wider(names_from=c(Index,Group), values_from = "value") %>% 
  mutate(selection_Wild=HeS_Wild+HoS_Wild, selection_Dom=HeS_Domesticated+HoS_Domesticated) %>% 
  select(TopTaxon.Order,selection_Wild, selection_Dom) %>% 
  mutate(difference=selection_Dom-selection_Wild) %>% 
  filter(abs(difference)>0.04) %>% 
  filter(!is.na(TopTaxon.Order)) %>% 
  mutate(TopTaxon.Order=fct_reorder(TopTaxon.Order, difference)) %>% 
  ggplot(aes( TopTaxon.Order, difference))+
  geom_bar(stat="identity", color="black", width = 0.8)+
  ylab("Difference in selection (%)")+
  theme_Publication(base_size = 12)+
  theme(axis.text.x=element_text(angle=45,hjust=1))+
  coord_flip()


RI_fam %>% 
  filter(Index%in%c("HeS","HoS","DL","HD","DR")) %>% 
  filter(Group%in%c("Wild","Domesticated")) %>% 
  mutate(value=as.numeric(RI)) %>%
  group_by(Index, Group,  TopTaxon.Phylum) %>% 
  summarise(value=mean(value)) %>% 
  pivot_wider(names_from=c(Index,Group), values_from = "value") %>% 
  mutate(selection_Wild=HeS_Wild+HoS_Wild, selection_Dom=HeS_Domesticated+HoS_Domesticated) %>% 
  dplyr::select(TopTaxon.Phylum,selection_Wild, selection_Dom) %>% 
  mutate(difference=selection_Dom-selection_Wild) %>% 
  filter(abs(difference)>0.04) %>% 
  filter(!is.na(TopTaxon.Phylum)) %>%
  #mutate(TopTaxon.Order=ifelse(TopTaxon.Order=="Veillonellales-Selenomonadales", "Selenomonadales", TopTaxon.Order)) %>% 
  mutate(TopTaxon.Phylum=fct_reorder(TopTaxon.Phylum, difference)) %>% 
  ggplot(aes( TopTaxon.Phylum, difference))+
  geom_bar(stat="identity", color="black", width = 0.8)+
  ylab("Difference in selection (%)")+
  theme_Publication(base_size = 12)+
  theme(axis.text.x=element_text(angle=45,hjust=1))+
  coord_flip()


# Bins under hoogeneous selection. Overall, most bins are governed by DL and DR


groups=c("Domesticated", "Wild")

(bins.HoS <- icbin$Ptk %>% 
  filter(Group%in%groups, Index=="DominantProcess") %>% 
  gather(key="bins", value ="Dom_process", 5:58) %>% 
  filter(Dom_process=="HoS") %>% 
  mutate(bins=str_replace(bins, "b", "B")))


icbin$Bin.TopClass %>% 
  filter(Bin%in%bins.HoS$bins) %>% 
  ggplot() +
  geom_bar(aes(fill=Genus.maxNamed, x=Bin, y=Genus.maxNamed.Percent), color="black",position="stack",stat="identity")+
  theme_Publication(base_family = 12)+
  ylab("Relative abundance within Bin")


# Bins under DL. 

groups=c("Domesticated", "Wild")

bins.DL <- icbin$Ptk %>% 
  filter(Group%in%groups, Index=="DominantProcess") %>% 
  gather(key="bins", value ="Dom_process", 5:58) %>%
  mutate(bins=str_replace(bins, "b", "B"))

icbin$Bin.TopClass %>% 
  filter(Bin%in%bins.DL$bins) %>% 
  ggplot() +
  geom_bar(aes(fill=Genus.maxNamed, x=Bin, y=Genus.maxNamed.Percent), color="black",position="stack",stat="identity")+
  theme_Publication(base_family = 12)+
  ylab("Relative abundance within Bin")






